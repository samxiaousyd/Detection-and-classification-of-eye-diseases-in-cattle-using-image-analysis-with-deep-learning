# -*- coding: utf-8 -*-
"""Calculate mAP for testing set.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Shb9m22cIBEGiZut5ktJwKwYJS_AsqF7
"""

import os
import numpy as np

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
# %cd /content/drive/MyDrive/YOLOv8

def read_boxes_from_file(file_path):
    with open(file_path, 'r') as file:
        lines = file.readlines()
    # Extract class and coordinates (x, y, w, h) from the first row
    if lines:
        return np.array([list(map(float, lines[0].strip().split()[1:]))])
    else:
        return np.array([])

def calculate_iou(box1, box2):
    # box format: [xmin, ymin, xmax, ymax]
    x1, y1, w1, h1 = box1
    x2, y2, w2, h2 = box2

    intersect_x = max(0, min(x1 + w1, x2 + w2) - max(x1, x2))
    intersect_y = max(0, min(y1 + h1, y2 + h2) - max(y1, y2))
    intersect_area = intersect_x * intersect_y

    area1 = w1 * h1
    area2 = w2 * h2
    union_area = area1 + area2 - intersect_area

    iou = intersect_area / union_area if union_area > 0 else 0
    return iou

def calculate_precision_at_iou(gt_boxes, pred_boxes, iou_threshold):
    # Calculate precision at a given IoU threshold
    true_positives = 0
    false_positives = 0

    for pred_box in pred_boxes:
        max_iou = 0
        for gt_box in gt_boxes:
            iou = calculate_iou(pred_box, gt_box)
            max_iou = max(max_iou, iou)

        if max_iou >= iou_threshold:
            true_positives += 1
        else:
            false_positives += 1

    precision = true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0
    return precision


def evaluate_mAP(predicted_dir, ground_truth_dir, iou_thresholds):
    predicted_files = os.listdir(predicted_dir)

    all_detections = []
    all_annotations = []

    for file_name in predicted_files:
        predicted_path = os.path.join(predicted_dir, file_name)
        ground_truth_path = os.path.join(ground_truth_dir, file_name)

        # Skip files that are missing in either predicted or ground truth
        if not os.path.exists(ground_truth_path):
            continue

        predicted_boxes = read_boxes_from_file(predicted_path)
        ground_truth_boxes = read_boxes_from_file(ground_truth_path)

        all_detections.append(predicted_boxes)
        all_annotations.append(ground_truth_boxes)

    num_images = len(all_detections)

    mean_average_precisions = []

    for iou_threshold in iou_thresholds:
        average_precisions = []

        for i in range(num_images):
            detections = all_detections[i]
            annotations = all_annotations[i]

            if len(annotations) == 0 or len(detections) == 0:
                continue

            for detection in detections:  # Add this loop to iterate over detections
                iou_values = [calculate_iou(detection, annotation) for annotation in annotations]
                max_iou = max(iou_values)
                precision = 1 if max_iou >= iou_threshold else 0
                average_precisions.append(precision)

        if len(average_precisions) > 0:
            mean_average_precision = np.mean(average_precisions)
            mean_average_precisions.append(mean_average_precision)
        else:
            mean_average_precisions.append(0.0)

    mAP = np.mean(mean_average_precisions)
    return mAP

# Example usage:
predicted_dir = "/content/drive/MyDrive/YOLOv8/data1/runs/detect/predict/labels"
ground_truth_dir = "/content/drive/MyDrive/YOLOv8/data1/test/labels"
iou_thresholds = np.arange(0.5, 1.0, 0.05)  # IoU thresholds from 0.5 to 0.95 in steps of 0.05

mAP = evaluate_mAP(predicted_dir, ground_truth_dir, iou_thresholds)
print("Mean Average Precision (mAP):", mAP)

def calculate_iou(box1, box2):
    # box format: [xmin, ymin, xmax, ymax]
    x1, y1, x1b, y1b = box1
    x2, y2, x2b, y2b = box2

    intersect_x = max(0, min(x1b, x2b) - max(x1, x2))
    intersect_y = max(0, min(y1b, y2b) - max(y1, y2))
    intersect_area = intersect_x * intersect_y

    area1 = (x1b - x1) * (y1b - y1)
    area2 = (x2b - x2) * (y2b - y2)
    union_area = area1 + area2 - intersect_area

    iou = intersect_area / union_area if union_area > 0 else 0
    return iou

def calculate_recall_for_eyes(predicted_dir, ground_truth_dir, iou_threshold=0.5):
    predicted_files = os.listdir(predicted_dir)

    true_positives = 0
    false_negatives = 0

    for file_name in predicted_files:
        predicted_path = os.path.join(predicted_dir, file_name)
        ground_truth_path = os.path.join(ground_truth_dir, file_name)

        # Skip files that are missing in either predicted or ground truth
        if not os.path.exists(ground_truth_path):
            continue

        predicted_boxes = read_boxes_from_file(predicted_path)
        ground_truth_boxes = read_boxes_from_file(ground_truth_path)

        if len(ground_truth_boxes) == 0:
            false_negatives += 1
            continue

        eye_detected = False
        for pred_box in predicted_boxes:
            iou = calculate_iou(pred_box, ground_truth_boxes[0])  # Assuming one ground truth eye per image
            if iou >= iou_threshold:
                true_positives += 1
                eye_detected = True
                break

        if not eye_detected:
            false_negatives += 1

    recall = true_positives / (true_positives + false_negatives) if (true_positives + false_negatives) > 0 else 0
    return recall

# Example usage:
predicted_dir = "/content/drive/MyDrive/YOLOv8/data1/runs/detect/predict/labels"
ground_truth_dir = "/content/drive/MyDrive/YOLOv8/data1/test/labels"

recall = calculate_recall_for_eyes(predicted_dir, ground_truth_dir)
print("Recall for detecting eyes:", recall)